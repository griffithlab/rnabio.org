---
feature_text: |
  ## RNA-seq Bioinformatics
  Introduction to bioinformatics for RNA sequence analysis
title: Cell Type Annotation
categories:
    - Module-08-scRNA
feature_image: "assets/genvis-dna-bg_optimized_v1a.png"
date: 0008-03-01
---

## Cell Type Annotation


### Why do we care about assigning cell type annotations to single cell RNAseq data?
Annotating cells in single-cell gene expression data is an active area of research. Defining a cell type can be challenging because of two fundamental reasons. One, gene expression levels are not discrete and mostly on a continuum; and two, differences in gene expression do not always translate to differences in cellular function ([Pasquini et al.](https://www.csbj.org/article/S2001-0370(21)00019-2/fulltext)). The field is growing and rapidly changing due to the advent of different kinds of annotation tools, and the creation of multiple scRNA-seq databases ([Wang et al.](https://doi.org/10.1093/bfgp/elaa003)).

One way to assign cell type annotation is through web resources. They are relatively easy to use and do not require advanced level scripting or programming skills. Examples include [Azimuth](https://azimuth.hubmapconsortium.org/), [Tabula Sapiens](https://tabula-sapiens-portal.ds.czbiohub.org/), and [SciBet](http://scibet.cancer-pku.cn/). Researchers sometimes try both methods with multiple tools when performing the cell type annotation. In addition, it is also recommended to validate your annotation by experiments, statistical analysis, or consulting subject matter experts.

Methods for assigning cell types usually fall into one of two categories: 

1. **Databases with marker genes for manual annotation**: These databases contain marker genes for various cell types (mostly human and mouse). Using the marker genes in these databases, you can annotate the cells in your datasets. For example, if you are using 10x Genomics Loupe Browser, you will be able to find top differentially expressed genes for each cluster. You can then search the genes in the database to find out if they are marker genes for specific cell types. You may need to search multiple top genes in each cluster to be sure about the cell type. Depending on the complexity of the dataset and prior knowledge on the cell types, this process could be laborious and time-consuming.

2. **Resources for automated cell type annotation (reference-based)**: There are tools developed by the community for automatically annotating cells by comparing new data with existing references. In this article, we will highlight a few web tools that do not require any programming skills. A major limitation of these tools is that the quality of the results heavily depends on the quality of the pre-annotated reference datasets.

### Assigning cell annotations to our data

#### Loading libraries

First, we need to load the relevant libraries.
```R
library(SingleR)
library(celldex)

```

The following function provides normalized expression values of 830 microarray samples generated by [ImmGen](<http://www.immgen.org/) from pure populations of murine immune cells. The samples were processed and normalized as described in Aran, Looney and Liu et al. (2019), i.e., CEL files from the Gene Expression Omnibus (GEO; GSE15907 and GSE37448), were downloaded, processed, and normalized using the robust multi-array average (RMA) procedure on probe-level data. This dataset consists of 20 broad cell types ("label.main") and 253 finely resolved cell subtypes ("label.fine"). The subtypes have also been mapped to the Cell Ontology ("label.ont", if cell.ont is not "none"), which can be used for further programmatic queries. 

#### Specifying which reference dataset to use

```R
#cell typing with single R
#load singleR immgen reference
ref_immgen <- celldex::ImmGenData()

```

Calling the ImmGenData() function returns a SummarizedExperiment object containing a matrix of log-expression values with sample-level labels.

```R
ref_immgen

```


```bash
#result of calling the above ref_immgen function
class: SummarizedExperiment 
dim: 22134 830 
metadata(0):
assays(1): logcounts
rownames(22134): Zglp1 Vmn2r65 ... Tiparp Kdm1a
rowData names(0):
colnames(830):
  GSM1136119_EA07068_260297_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_1.CEL
  GSM1136120_EA07068_260298_MOGENE-1_0-ST-V1_MF.11C-11B+.LU_2.CEL
  ...
  GSM920654_EA07068_201214_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_1.CEL
  GSM920655_EA07068_201215_MOGENE-1_0-ST-V1_TGD.VG4+24ALO.E17.TH_2.CEL
colData names(3): label.main label.fine label.ont
```

Now let's see what each of the labels look like:

```R
head(ref_immgen$label.main, n=10)
```

From the main labels, we can see that we get general cell types such as Macrophages and Monocytes.

```R
[1] "Macrophages" "Macrophages" "Macrophages"
[4] "Macrophages" "Macrophages" "Macrophages"
[7] "Monocytes"   "Monocytes"   "Monocytes"  
[10] "Monocytes" 
```

```R
head(ref_immgen$label.fine)

```

From the fine labels, we can see that we start to subtype the more general cell types we saw above. So rather than seeing 6 labels for Macrophages we now see specific Macrophage types such as Macrophages (MF.11C-11B+).

```R
 [1] "Macrophages (MF.11C-11B+)"
 [2] "Macrophages (MF.11C-11B+)"
 [3] "Macrophages (MF.11C-11B+)"
 [4] "Macrophages (MF.ALV)"     
 [5] "Macrophages (MF.ALV)"     
 [6] "Macrophages (MF.ALV)"     
 [7] "Monocytes (MO.6+I-)"      
 [8] "Monocytes (MO.6+2+)"      
 [9] "Monocytes (MO.6+2+)"      
[10] "Monocytes (MO.6+2+)" 
```



```R
head(ref_immgen$label.ont, n=10)

```

From the ont labels, we can see that we start to subtypes are now mapped to Cell Ontology IDs.

```R
[1] "CL:0000235" "CL:0000235" "CL:0000235" "CL:0000583"
[5] "CL:0000583" "CL:0000583" "CL:0000576" "CL:0000576"
[9] "CL:0000576" "CL:0000576"
```

###

```R
#generate predictions for our seurat object
predictions_main = SingleR(test = GetAssayData(merged), 
                      ref = ref_immgen,
                      labels = ref_immgen$label.main)

predictions_fine = SingleR(test = GetAssayData(merged), 
                           ref = ref_immgen,
                           labels = ref_immgen$label.fine)

#add main labels to object
merged[['immgen_singler_main']] = rep('NA', ncol(merged))
merged$immgen_singler_main[rownames(predictions_main)] = predictions_main$labels

#add fine labels to object
merged[['immgen_singler_fine']] = rep('NA', ncol(merged))
merged$immgen_singler_fine[rownames(predictions_fine)] = predictions_fine$labels

DimPlot(merged, group.by = c("immgen_singler_main"))

DimPlot(merged, group.by = c("immgen_singler_fine"))

```


### Note on reference annotation datasets
As one might expect, the choice of reference can have a major impact on the annotation results. It's essential to choose a reference dataset encompassing a broader spectrum of labels than those expected in our test dataset. Trust in the appropriateness of labels assigned by the original authors to reference samples is often a leap of faith, and it's unsurprising that certain references outperform others due to differences in sample preparation quality. Ideally, we favor a reference generated using a technology or protocol similar to our test dataset, although this consideration is typically not an issue when using SingleR() for annotating well-defined cell types.

Users are advised to read the relevant vignette for more details about the available references as well as some recommendations on which to use. (As an aside, the ImmGen dataset and other references were originally supplied along with SingleR itself but have since been migrated to the separate celldex package for more general use throughout Bioconductor.) Of course, as we shall see in the next Chapter, it is entirely possible to supply your own reference datasets instead; all we need are log-expression values and a set of labels for the cells or samples


### Understanding Clustering using Celltyping

We know that the UMAP shape changes when we use different numbers of PCs but why does the UMAP shape change? Lets try creating a UMAP with only 5 PCs.

```R
merged_5PC <- RunUMAP(merged, dims = 1:5)

DimPlot(merged_5PC, label = TRUE, group.by = 'seurat_clusters_res1.2')

DimHeatmap(merged, dims = 1:5, balanced = TRUE, cells = 500)

```

We see that the cells form much more general clusters. For example, the immune cells are just in one big blob. When we increase our PCs we increase the amount of information that can be used to tease apart more specfic cell types. The distinct B cell cluster we saw earlier was only possible because we provided enough genetic expression information in the PCs we chose. 

![Seurat FindVariableFeatures](/assets/module_8/5PC_umap.png)


### Saving our data

Let's save our seurat objects to use in future sections.

```R
saveRDS(merged, file = "preprocessed_object.rds")

```
