---
feature_text: |
  ## RNA-seq Bioinformatics
  Introduction to bioinformatics for RNA sequence analysis
title: Single-cell RNA-seq
categories:
    - Module-08-scRNA
feature_image: "assets/genvis-dna-bg_optimized_v1a.png"
date: 0008-02-01
---

## Exercise: A Complete Seurat Workflow

In this exercise, we will analyze and interpret a small scRNA-seq data set consisting of three bone marrow samples. Two of the samples are from the same patient, but differ in that one sample was enriched for a particular cell type. The goal of this analysis is to determine what cell types are present in the three samples, and how the samples and patients differ. This was drawn in part from the Seurat vignettes at [https://satijalab.org/seurat/vignettes.html](https://satijalab.org/seurat/vignettes.html).

### Step 1: Preparation

Working at the linux command line in your home directory (/home/ubuntu/workspace), create a new directory for your output files called “scrna”. The full path to this directory will be /home/ubuntu/workspace/scrna. The command is:

```bash
cd ~/workspace
mkdir scrna
cd scrna
wget http://genomedata.org/rnaseq-tutorial/scrna/PlotMarkers.r
```

Start R (by typing ‘R’ at the command line) and load some R libraries as follows:

```R
library("Seurat");
library("sctransform");
library("dplyr");
library("RColorBrewer");
library("ggthemes");
library("ggplot2");
library("cowplot");
library("data.table");
```

Create a vector of convenient sample names, such as “A”, “B”, and “C”:

`samples = c("A","B","C");`

Create a variable called `outdir` to specify your output directory:

`outdir = "/home/ubuntu/workspace/scrna";`

### Step 2: Read in the feature-barcode matrices generated by the cellranger pipeline

```R
data.10x = list(); # first declare an empty list in which to hold the feature-barcode matrices
data.10x[[1]] <- Read10X(data.dir = "~/workspace/scRNA_data/ND050119_CD34_3pV3/filtered_feature_bc_matrix");
data.10x[[2]] <- Read10X(data.dir = "~/workspace/scRNA_data/ND050119_WBM_3pV3/filtered_feature_bc_matrix");
data.10x[[3]] <- Read10X(data.dir = "~/workspace/scRNA_data/ND050819_WBM_3pV3/filtered_feature_bc_matrix");
```

### Step 3: Convert each feature-barcode matrix to a Seurat object

This simultaneously performs some initial filtering in order to exclude genes that are expressed in fewer than 100 cells, and to exclude cells that contain fewer than 700 expressed genes. Note that min.cells=10 and min.features=100 are more common parameters at this stage, but we are filtering more aggressively in order to make the data set smaller. At this step, we also create a “DataSet” identity for each cell.

```R
scrna.list = list(); # First create an empty list to hold the Seurat objects
scrna.list[[1]] = CreateSeuratObject(counts = data.10x[[1]], min.cells=100, min.features=700, project=samples[1]);
scrna.list[[1]][["DataSet"]] = samples[1];
scrna.list[[2]] = CreateSeuratObject(counts = data.10x[[2]], min.cells=100, min.features=700, project=samples[2]);
scrna.list[[2]][["DataSet"]] = samples[2];
scrna.list[[3]] = CreateSeuratObject(counts = data.10x[[3]], min.cells=100, min.features=700, project=samples[3]);
scrna.list[[3]][["DataSet"]] = samples[3];
```

Aside: Note that you can do this more efficiently, especially if you have many samples, using a ‘for’ loop:

```R
for (i in 1:length(data.10x)) {
    scrna.list[[i]] = CreateSeuratObject(counts = data.10x[[i]], min.cells=100, min.features=700, project=samples[i]);
    scrna.list[[i]][["DataSet"]] = samples[i];
}
```

Finally, remove the raw data to save space:

`rm(data.10x);`

### Step 4. Merge the Seurat objects into a single object

We will call this object `scrna`. We also give it a project name (here, "CSHL"), and prepend the appropriate data set name to each cell barcode. For example, if a barcode from data set "B" is originally `AATCTATCTCTC`, it will now be `B_AATCTATCTCTC`. Then clean up some space by removing `scrna.list`. Finally, save the merged object as an RDS file. Should you need to load this file into R at any time, it can be done using the `readRDS` command.

```R
scrna <- merge(x=scrna.list[[1]], y=c(scrna.list[[2]],scrna.list[[3]]), add.cell.ids = c("A","B","C"), project="CSHL");
rm(scrna.list); # save some space
str(scrna@meta.data) # examine the structure of the Seurat object meta data
saveRDS(scrna, file = sprintf("%s/MergedSeuratObject.rds", outdir));
```

### Aside on accessing the Seurat object meta data, which is stored in scrna@meta.data

Meta data can be used to hold the following information (and more) for your data set:

* Summary statistics
* Sample name
* Cluster membership for each cell
* Cell cycle phase for each cell
* Batch or sample for each cell
* Other custom annotations for each cell

You can access and query the meta data using commands such as:

```R
scrna[[]];
scrna@meta.data;
str(scrna@meta.data); # Examine structure and contents of meta data
head(scrna@meta.data$nFeature_RNA); # Access genes (“Features”) for each cell
head(scrna@meta.data$nCount_RNA); # Access number of UMIs for each cell:
levels(x=scrna); # List the items in the current default cell identity class
length(unique(scrna@meta.data$seurat_clusters)); # How many clusters are there? Note that there will not be any clusters in the meta data until you perform clustering.
unique(scrna@meta.data$Batch); # What batches are included in this data set?
scrna$NewIdentity <- vector_of_annotations; # Assign new cell annotations to a new "identity class" in the meta data
```

### Step 5. Quality control plots

Plot the distributions of several quality-control variables in order to choose appropriate filtering thresholds. The number of genes and UMIs (nGene and nUMI) are automatically calculated for every object by Seurat. However, you will need to manually calculate the mitochondrial transcript percentage and ribosomal transcript percentage for each cell, and add them to the Seurat object meta data, as shown below.

Calculate the mitochondrial transcript percentage for each cell:

```R
mito.genes <- grep(pattern = "^MT-", x = rownames(x = scrna), value = TRUE);
percent.mito <- Matrix::colSums(x = GetAssayData(object = scrna, slot = 'counts')[mito.genes, ]) / Matrix::colSums(x = GetAssayData(object = scrna, slot = 'counts'));
scrna[['percent.mito']] <- percent.mito;
```

Calculate the ribosomal transcript percentage for each cell:

```R
ribo.genes <- grep(pattern = "^RP[SL][[:digit:]]", x = rownames(x = scrna), value = TRUE);
percent.ribo <- Matrix::colSums(x = GetAssayData(object = scrna, slot = 'counts')[ribo.genes, ]) / Matrix::colSums(x = GetAssayData(object = scrna, slot = 'counts'));
scrna[['percent.ribo']] <- percent.ribo;
```

Plot as violin plots, which will be located in, for example, ~/workspace/scrna/VlnPlot.jpg. All figures can be downloaded using the scp command, or viewed on the AWS server.

```R
jpeg(sprintf("%s/VlnPlot.jpg", outdir), width = 13, height = 6, units="in", res=300);
vln <- VlnPlot(object = scrna, features = c("percent.mito", "percent.ribo"), pt.size=0, ncol = 2, group.by="DataSet");
print(vln);
dev.off();

jpeg(sprintf("%s/VlnPlot.nCount.25Kmax.jpg", outdir), width = 10, height = 10, units="in", res=300)
vln <- VlnPlot(object = scrna, features = "nCount_RNA", pt.size=0, group.by="DataSet", y.max=25000)
print(vln)
dev.off();

jpeg(sprintf("%s/VlnPlot.nFeature.jpg", outdir), width = 10, height = 10, units="in", res=300)
vln <- VlnPlot(object = scrna, features = "nFeature_RNA", pt.size=0, group.by="DataSet")
print(vln)
dev.off()
```

QUESTIONS:

1. Excessive mitochondrial transcripts can indicate the presence of dead cells, which tend to cluster together. Based on the distribution of mitochondrial transcripts, what filter threshold would you set for mitochondrial transcripts? One approach is to start with a lenient threshold, work through the analysis, and determine later whether your data still contains clusters of dead cells.
2. Compare the distribution of ribosomal transcripts, total transcripts, and genes in each sample. Are differences in these parameters necessarily a technical artifact, or might they contain information about the biology of the samples?

Next, we will use Seurat’s FeatureScatter function to create scatterplots of the relationships among QC variables. This can be helpful in selecting filtering thresholds. More generally, this is a very useful wrapper function that can be used to visualize relationships between any pair of quantitative variables in the Seurat object (including expression levels, etc).

```R
jpeg(sprintf("%s/Scatter1.jpg", outdir), width = 8, height = 6, units="in", res=300);
scatter <- FeatureScatter(object = scrna, feature1 = "nCount_RNA", feature2 = "percent.mito", pt.size=0.1)
print(scatter);
dev.off();

jpeg(sprintf("%s/Scatter2.jpg", outdir), width = 8, height = 6, units="in", res=300);
scatter <- FeatureScatter(object = scrna, feature1 = "nCount_RNA", feature2 = "percent.ribo", pt.size=0.1)
print(scatter);
dev.off();

jpeg(sprintf("%s/Scatter3.jpg", outdir), width = 8, height = 6, units="in", res=300);
scatter <- FeatureScatter(object = scrna, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", pt.size=0.1)
print(scatter);
dev.off();
```

### Step 6. Calculate a cell cycle score for each cell

This can be used to determine whether heterogeneity in cell cycle phase is driving the tSNE/UMAP layout and/or clustering. This may or may not be obscuring the signal you care about, depending on your analysis goals and the nature of the data. (If necessary, it can be removed in a later step.) It is also useful for determining whether certain populations of cells are more proliferative than others. The list of cell cycle genes, and the scoring method, was taken from Tirosh I, et al. (2016).

```R
cell.cycle.tirosh <- read.csv("http://genomedata.org/rnaseq-tutorial/scrna/CellCycleTiroshSymbol2ID.csv", header=TRUE); # read in the list of genes
s.genes = cell.cycle.tirosh$Gene.Symbol[which(cell.cycle.tirosh$List == "G1/S")]; # create a vector of S-phase genes
g2m.genes = cell.cycle.tirosh$Gene.Symbol[which(cell.cycle.tirosh$List == "G2/M")]; # create a vector of G2/M-phase genes
scrna <- CellCycleScoring(object=scrna, s.features=s.genes, g2m.features=g2m.genes, set.ident=FALSE)
```

### Step 7. Filter the cells to remove debris, dead cells, and probable doublets

**QUESTION:** How many cells are there in each sample before filtering? The ‘table’ function may come in handy.

First calculate some basic statistics on the various QC parameters, which can be helpful for choosing cutoffs. For example:

```R
min <- min(scrna@meta.data$nFeature_RNA);
m <- median(scrna@meta.data$nFeature_RNA)
max <- max(scrna@meta.data$nFeature_RNA)    
s <- sd(scrna@meta.data$nFeature_RNA)
min1 <- min(scrna@meta.data$nCount_RNA)
max1 <- max(scrna@meta.data$nCount_RNA)
m1 <- mean(scrna@meta.data$nCount_RNA)
s1 <- sd(scrna@meta.data$nCount_RNA)
Count93 <- quantile(scrna@meta.data$nCount_RNA, 0.93) # calculate value in the 93rd percentile
print(paste("Feature stats:",min,m,max,s));
print(paste("UMI stats:",min1,m1,max1,s1,Count93));
```

Now, filter the data using the subset function and your chosen thresholds. Note that for large data sets with diverse samples, it may be beneficial to use sample-specific thresholds for some parameters. If you are not sure what thresholds to use, the following will work well for the purposes of this course:

```R
scrna <- subset(x = scrna, subset = nFeature_RNA > 700  & nCount_RNA < Count93 & percent.mito < 0.1)
```

QUESTION: How many cells are there in each sample after filtering?

### Step 8. **[Optional]** Subset the data

If necessary, you can subset the data set to N cells (2000, 5000, etc) to make it more manageable:

```R
subcells <- sample(Cells(scrna), size=N, replace=F)
scrna <- subset(scrna, cells=subcells)
```

### Step 9. Normalize the data, detect variable genes, and scale the data

Normalize the data:

```R
scrna <- NormalizeData(object = scrna, normalization.method = "LogNormalize", scale.factor = 1e6);
```

QUESTION: What does LogNormalize do mathematically? Are there other normalization options available?

Now identify and plot the most variable genes, which will be used for downstream analyses. This is a critical step that reduces the contribution of noise. Consider adjusting the cutoffs if you think (often based on prior knowledge of your experimental system) that important genes are being excluded.

```R
scrna <- FindVariableFeatures(object = scrna, selection.method = 'vst', mean.cutoff = c(0.1,8), dispersion.cutoff = c(1, Inf))
print(paste("Number of Variable Features: ",length(x = VariableFeatures(object = scrna))));

pdf(sprintf("%s/VG.file", outdir), useDingbats=FALSE)
vg <- VariableFeaturePlot(scrna)
print(vg);
dev.off()
```

Scale and center the data:

```R
scrna <- ScaleData(object = scrna, features = rownames(x = scrna), display.progress=FALSE);
```

Alternatively, you can scale the data and simultaneously remove unwanted signal associated with variables such as cell cycle phase, ribosomal transcript content, etc. (This is slow, and cannot be done in the time allotted for this course.) To remove cell cycle signal, for instance:

```R
# scrna <- ScaleData(object = scrna, features = rownames(x = scrna), vars.to.regress = c("S.Score","G2M.Score"), display.progress=FALSE);
```

Save the normalized, scaled Seurat object:

```R
saveRDS(scrna, file = sprintf("%s/VST.rds", outdir));
```

**DIGRESSION:** How can you use Seurat-processed data with packages that are not compatible with Seurat? Other packages may require the data to be normalized in a specific way, and often require an expression matrix (not a Seurat object) as input. As an example, here we prepare an expression data matrix for use with the popular CNV-detection package CONICSmat:

```R
scrna.cnv <- NormalizeData(object = scrna, normalization.method = "RC", scale.factor = 1e5);
data.cnv <- GetAssayData(object=scrna.cnv, slot="data"); # get the normalized data
log2data = log2(data.cnv+1); # add 1 then take log2
df <- as.data.frame(as.matrix(log2data)); # convert it to a data frame
cells <- as.data.frame(colnames(df));
genes <- as.data.frame(rownames(df));
# save as text files:
fwrite(x = genes, file = "genes.csv", col.names=FALSE);
fwrite(x = cells, file = "cells.csv", col.names=FALSE);
fwrite(x = df, file = "exp.csv", col.names=FALSE);
```

### Step 10. Reduce the dimensionality of the data using Principal Component Analysis

Subsequent calculations, such as those used to derive the tSNE and UMAP projections, and the k-Nearest Neighbor graph used for clustering, are performed in a new space with fewer dimensions, namely, the principal components. Here, specify a relatively large number of principal components – more than you anticipate using for downstream analyses. Then use several techniques to characterize the components and estimate the number of principal components that captures the signal of interest while minimizing noise.

Perform Principal Component Analysis (PCA), and save the first 100 components:

```R
scrna <- RunPCA(object = scrna, npcs = 100, verbose = FALSE);
```

**OPTIONAL:** Then run ProjectDim, which scores each gene in the dataset (including genes not included in the PCA) based on their correlation with the calculated components. This is not used elsewhere in this pipeline, but it can be useful for exploring genes that are not among the 2000 most highly variable genes selected above.

```R
scrna <- ProjectDim(object = scrna)
```

**QUESTION:** What do the principal components “mean” from a biological standpoint? What genes contribute to the principal components? Do they represent biological processes of interest, or technical variables (such as mitochondrial transcripts) that suggest the data may need to be filtered differently?

There are several easy ways to investigate these questions. First, visualize the PCA “loadings.” Each “component” identified by PCA is a linear combination, or weighted sum, of the genes in the data set. Here, the “loadings” represent the weights of the genes in any given component. These plots tell you which genes contribute most to each component:

```R
jpeg(sprintf("%s/VizDimLoadings.jpg", outdir), width = 8, height = 30, units="in", res=300);
vdl <- VizDimLoadings(object = scrna, dims = 1:3)
print(vdl);
dev.off();
```

Second, use the DimHeatmap function to generate heatmaps that summarize the expression of the most highly weighted genes in each principal component. As noted in the Seurat documentation, “both cells and genes are ordered according to their PCA scores. Setting cells.use to a number plots the 'extreme' cells on both ends of the spectrum, which dramatically speeds plotting for large datasets. Though clearly a supervised analysis, we find this to be a valuable tool for exploring correlated gene sets.

```R
jpeg(sprintf("%s/PCA.heatmap.multi.jpg", outdir), width = 8.5, height = 24, units="in", res=300);
hm.multi <- DimHeatmap(object = scrna, dims = 1:12, cells = 500, balanced = TRUE);
print(hm.multi);
dev.off();
```

Finally, you can generate ranked lists of the genes in each principal component and perform functional enrichment or Gene Set Enrichment Analysis. (This [tool](https://toppgene.cchmc.org/enrichment.jsp) offers a quick and easy way to determine functional enrichment from a list of genes.) For example, for the first principal component:

`PClist_1 <- names(sort(Loadings(object=scrna, reduction="pca")[,1], decreasing=TRUE));`

Now, decide how many components to use in downstream analyses. This number usually varies from 5-50, depending on the number of cells and the complexity of the data set. Although there is no “correct” answer, using too few components risks missing meaningful signal, and using too many risks diluting meaningful signal with noise.

There are several ways to make an informed decision. The first is to use the principal component heatmaps generated above. Components that generate noisy heatmaps likely correspond to noise. The second method is to examine a plot of the standard deviations of the principle components, and to choose a cutoff to the left of the bend in this so-called “elbow plot.”

Generate an elbow plot of principal component standard deviations:

```R
elbow <- ElbowPlot(object = scrna)
jpeg(sprintf("%s/PCA.elbow.jpg", outdir), width = 6, height = 8, units="in", res=300);
print(elbow);
dev.off();
```

Next, use a bootstrapping technique called Jackstraw analysis to estimate a p-value for each component, print out a plot, and save the p-values to a file:

```R
scrna <- JackStraw(object = scrna, num.replicate = 100, dims=30); # takes around 4 minutes
scrna <- ScoreJackStraw(object = scrna, dims = 1:30)
jpeg(sprintf("%s/PCA.jackstraw.jpg", outdir), width = 10, height = 6, units="in", res=300);
js <- JackStrawPlot(object = scrna, dims = 1:30)
print(js);
dev.off();
pc.pval <- scrna@reductions$pca@jackstraw@overall.p.values; # get p-value for each PC
write.table(pc.pval, file=sprintf("%s/PCA.jackstraw.scores.xls", outdir, date), quote=FALSE, sep='\t', col.names=TRUE);
```

### Step 11. Generate 2-dimensional layouts of the data using two related algorithms, t-SNE and UMAP

Use the number of principal components (nPC) you selected above.

```R
nPC = 10;
scrna <- RunUMAP(object = scrna, reduction = "pca", dims = 1:nPC);
scrna <- RunTSNE(object = scrna, reduction = "pca", dims = 1:nPC);
```

Now, plot the tSNE and UMAP plots next to each other in one figure, and color each data set separately:

```R
jpeg(sprintf("%s/UMAP.%d.jpg", outdir, nPC), width = 10, height = 8, units="in", res=300);
p1 <- DimPlot(object = scrna, reduction = "tsne", group.by = "DataSet", pt.size=0.1)
p2 <- DimPlot(object = scrna, reduction = "umap", group.by = "DataSet", pt.size=0.1)
print(plot_grid(p1, p2));
dev.off();
```

**QUESTIONS:**

1. How do the data sets compare to each other? (We will further investigate these differences in subsequent steps.)
2. How does the number of principal components used affect the layout?
3. What are the chief sources of variation in this data, as suggested by the t-SNE and UMAP layouts? Are there confounding technical variables that may be driving the layouts? What are some likely technical variables?

Color the t-SNE and UMAP plots by some potential confounding variables. Here’s an example in which we color each cell according to the number of UMIs it contains:

```R
feature.pal = rev(colorRampPalette(brewer.pal(11,"Spectral"))(50)); # a useful color palette
jpeg(sprintf("%s/umap.%d.colorby.UMI.jpg", outdir, nPC), width = 10, height = 8,  units="in", res=300);
fp <- FeaturePlot(object = scrna, features = c("nCount_RNA"), cols = feature.pal, pt.size=0.1, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank()); # the text after the ‘+’ simply removes the axis using ggplot syntax
print(fp);
dev.off();
```

**QUESTION:** What is the relationship between the principal components and the t-SNE/UMAP layout?

To investigate this, plot several principal components on the t-SNE/UMAP, for example the following code plots the first principal component and prints the plot to a file:

```R
jpeg(sprintf("%s/UMAP.%d.colorby.PCs.jpg", outdir, nPC), width = 12, height = 6, units="in", res=100);
redblue=c("blue","gray","red"); # another useful color scheme
fp1 <- FeaturePlot(object = scrna, features = 'PC_1', cols=redblue, pt.size=0.1, reduction = "umap")+ theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank());
print(fp1);
dev.off();
```

### Step 12: Infer cell types

There are many sophisticated methods for doing this (e.g. SingleR). But the simplest and most common approach is to plot the expression levels of marker genes for known cell types. Markers for bone-marrow-relevant cell types are provided in the file ~/workspace/scRNA_data/gene_lists_human_180502.csv. To plot three genes of your choice, GENE1, GENE2, and GENE3:

```R
jpeg(sprintf("%s/geneplot.jpg", outdir), units="in", res=300, height=6, width=6);
fp <- FeaturePlot(object = scrna, features = c(GENE1, GENE2, GENE3), cols = c("gray","red"), ncol=2, reduction = "umap") + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank());
print(fp);
dev.off();
```

Now use the code that we downloaded from [here](http://genomedata.org/rnaseq-tutorial/scrna/PlotMarkers.r) to color the UMAP according to the expression of the markers in gene_lists_human_180502.csv:

```R
source("~/workspace/scrna/PlotMarkers.r")
```

During the differential expression analysis in Step 14, which will take about 10 minutes to run, use these plots to make inferences about cell type.

### Step 13: Cluster the cells using a graph-based clustering algorithm

The first step is to generate the k-Nearest Neighbor (KNN) graph using the number of principal components chosen above (nPC). The second step is to partition the graph into "cliques" or clusters using the Louvain modularity optimization algorithm. At this step, the cluster resolution (cluster.res) may be specified. (Larger numbers generate more clusters.) While there is no “correct” number of clusters, it can be preferable to err on the side of too many clusters. For this exercise, please use the following:

```R
nPC = 10;
cluster.res = 0.2;
scrna <- FindNeighbors(object=scrna, dims=1:nPC);
scrna <- FindClusters(object=scrna, resolution=cluster.res);
```

The output of FindClusters is saved in scrna@meta.data$seurat_clusters. Note that this is reset each time clustering is performed. To ensure that each clustering result is saved, save the result as a new identity class, and give it a custom name that reflects the clustering resolution and number of principal components:

```R
scrna[[sprintf("ClusterNames_%.1f_%dPC", cluster.res, nPC)]] <- Idents(object = scrna);
```

Inspect the structure of the meta data, then save the Seurat object, which now contains t-SNE and UMAP coordinates, and clustering results:

```R
str(scrna@meta.data);
saveRDS(scrna, file = sprintf("%s/VST.PCA.UMAP.TSNE.CLUST.rds", outdir));
```

**QUESTION:** How many graph-based clusters are there? (This number is 'n.graph' and is used below.) How do they relate to the 2-D layouts? How does this depend on the number of components and the clustering resolution?

First plot graph-based clusters on 2-D layouts:

```R
n.graph = length(unique(scrna[[sprintf("ClusterNames_%.1f_%dPC",cluster.res, nPC)]][,1])); # automatically get the number of clusters from a specific clustering run
```

Or more simply, use the most recent default clustering result:

```R
n.graph = length(unique(scrna@meta.data$seurat_clusters));

rainbow.colors = rainbow(n.graph, s=0.6, v=0.9); # color palette
jpeg(sprintf("%s/UMAP.clusters.jpg", outdir), width = 10, height = 6, units="in", res=300);
p <- DimPlot(object = scrna, reduction = "umap", group.by = "seurat_clusters", cols = rainbow.colors, pt.size=0.1, label=TRUE) + theme(axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank());
print(p);
dev.off();
```

**QUESTION:** Are there sample-specific clusters? How many cells are in each cluster and each sample?

```R
cluster.breakdown <- table(scrna@meta.data$DataSet, scrna@meta.data$seurat_clusters);
```

**QUESTION:** What do the clusters represent? How do they differ from each other? Start with a differential expression analysis:

### Step 14: Interpret the clustering using a differential gene expression (DEG) analysis

Perform DEG analysis on all clusters simultaneously using the default differential expression test (Wilcoxon), then save the results to a file. This will take 10-15 minutes using the parameters here, which were chosen to make this step run faster, and are not necessarily ideal for all situations. (While this is running, use the plots generated in Step 12 to figure out what types of cells are present in this data set.) Now compute the DEGs and save to a file:

```R
DEGs <- FindAllMarkers(object=scrna, logfc.threshold=1, min.diff.pct=.2);
write.table(DEGs, file=sprintf("%s/DEGs.Wilcox.xls", outdir), quote=FALSE, sep="\t", row.names=FALSE);
```

Examine the contents and structure of DEGs. How many DEGs are there? What values are contained in this output? Now choose the top 10 DEGs in each cluster, and print them to a heatmap using DoHeatmap and a red/white/blue color scheme:

```R
top10 <- DEGs %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC);
jpeg(sprintf("%s/heatmap.jpg", outdir), units="in", res=300, height=20, width=15);
DoHeatmap(scrna, features=top10$gene, slot="scale.data", disp.min=-2, disp.max=2, group.by="ident", group.bar=TRUE) + scale_fill_gradientn(colors = c("blue", "white", "red")) + theme(axis.text.y = element_text(size = 10));
dev.off();
```

**Questions pertaining to cell type inference and DEG analysis:**

1. What cell types are present?
2. Plot some DEGs using FeaturePlot. What is more reliable or informative: the statistical significance or the log fold-change of the DEG?
3. Do different clusters correspond to different cell types? (Should they?)
4. Are the DEGs helpful for identifying cell types?
5. Does cell type correlate with other parameters (e.g. UMI, number of genes, cell cycle phase, etc?)

## Independent exercises, if time permits

* Perform a sample-wise differential expression analysis. Then make a heatmap and perform functional enrichment analysis of the differentially expressed genes. Overall, how do the samples differ from each other?

* Experiment with the number of components, the clustering resolution, and the DEG filtering thresholds to understand how these parameters affect the results. What set of parameters provides the closest correspondence between cell type and cluster?  

* Perform batch correction using the sample code provided during the lecture. Assign each sample to its own batch, and repeat the analysis. How does batch correction affect the result?

* Subset the T-cells, assign them to a new Seurat object, and re-analyze them in isolation. Does this improve your ability to resolve T-cell subsets?
