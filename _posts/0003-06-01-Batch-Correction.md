---
feature_text: |
  ## RNA-seq Bioinformatics
  Introduction to bioinformatics for RNA sequence analysis
title: Batch Correction
categories:
    - Module-03-Expression
feature_image: "assets/genvis-dna-bg_optimized_v1a.png"
date: 0003-06-01
---

***

![RNA-seq_Flowchart4](/assets/module_3/RNA-seq_Flowchart4.png)

***

# NOTE this module is UNDER CONSTRUCTION

In this section we will use the ComBat-Seq tool in R (Bioconductor) to demonstrate the principle and application of batch correction. Due to the way our test data was generated (at a single center, at one time, with consistent methodology) we do NOT expect batch effects in these data.  Therefore we will use a different dataset to demonstrate the impact of Batch correction in this module. 

### Introduction to Batch correction
We highly recommend reading the entire [ComBat-Seq manuscript](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7518324/) by Yuqing Zhang, Giovanni Parmigiani, and W Evan Johnson. This manuscript does a beautiful job of briefly introducing the concept of batch correction and the differences between `normalization` and `batch correction`. If you find this exercise helpful in your research, please cite the ComBat-Seq paper ([PMID: 33015620](https://pubmed.ncbi.nlm.nih.gov/33015620/)).

In particular, this excerpt covers the basics:
> Genomic data are often produced in batches due to logistical or practical restrictions, but technical variation and differences across batches, often called batch effects, can cause significant heterogeneity across batches of data. Batch effects often result in discrepancies in the statistical distributions across data from different technical processing batches, and can have unfavorable impact on downstream biological analysis ...

> Batch effects often cannot be fully addressed by normalization methods and procedures. The differences in the overall expression distribution of each sample across batch may be corrected by normalization methods, such as transforming the raw counts to (logarithms of) CPM, TPM or RPKM/FPKM, the trimmed mean of M values (TMM), or relative log expression (RLE). However, batch effects in composition, i.e. the level of expression of genes scaled by the total expression (coverage) in each sample, cannot be fully corrected with normalization. ... while the overall distribution of samples may be normalized to the same level across batches, individual genes may still be affected by batch-level bias.

### Download and prepare some test data where some batch effects are expected
For this exercise we obtain public RNA-seq data from an extensive multi-platform comparison of sequencing platforms that also examined the impact of generating data at multiple sites, using polyA vs ribo-reduction for enrichment, and the impact of RNA degradation ([PMID: 25150835](https://pubmed.ncbi.nlm.nih.gov/25150835/)): "Multi-platform and cross-methodological reproducibility of transcriptome profiling by RNA-seq in the ABRF Next-Generation Sequencing Study".

This publication used the same UHR and HBR samples we have been using throughout this course. To examine a strong batch effect we will consider a DE analysis of UHR vs HBR where we compare Ribo-depleted (RD) and polyA-enriched (PE) samples. 

If we do DE analysis of UHR vs. HBR for replicates that are consistent with respect to Ribo-depletion or PolyA-enrichment, how does the compare to the results where we compare Ribo-depleted data vs PolyA-enriched data?  If you do batch correction and redo these comparisons does it make the results more comparable? i.e. can we correct for the technical differences and see the same biological differences?

This is a bit contrived because there really are true biological differences expected for polyA vs. Ribo-depleted data. To counter this, we will limit the analysis to only know protein coding genes.

This exercise is also a bit simplistic in the sense that we have perfectly balanced conditions and batches. Our conditions of interest are: HBR (brain) vs. UHR (cancer cell line) expression patterns.  Our batches are the two methods of processing: Riboreduction and PolyA enrichment. And we have 4 replicates of both conditions in both batches.  To perform this kind of batch correction you need at least some representation of each of your conditions of interest in each batch.  So, for example, if we processed all the HBR samples with Riboreduction and all the UHR samples with PolyA enrichment, we would be unable to model the batch effect vs the condition effect.  

There are also other experiments from this dataset we could use instead. For example, different levels of degradation?, data generated by different labs? [Figure 1](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4167418/) and [Figure 2](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4167418/) give a nice high level summary of all the data generated.

The entire RNA-seq dataset for [PMID: 25150835](https://pubmed.ncbi.nlm.nih.gov/25150835/) has been deposited in GEO. In GEO, these data are organized as a `superseries`: [GSE46876](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE46876) which has data for several sequencing platforms. The data from the Illumina Platform are part of this `subseries`: [GSE48035](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE48035).

To do this analysis quickly, we will download pre-computed raw read counts for this dataset: [GSE48035_ILMN.counts.txt.gz](https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE48035&format=file&file=GSE48035%5FILMN%2Ecounts%2Etxt%2Egz)

Set up a working directory and download the RNA-seq counts file needed for the following exercise as follows:

```bash
cd $RNA_HOME
mkdir batch_correction
cd batch_correction
wget http://genomedata.org/rnaseq-tutorial/batch_correction/GSE48035_ILMN.counts.txt.gz

```

Create a simplified version of this file that has only the counts for the samples we wish to use for this analysis as follows:

```bash
cd $RNA_HOME/batch_correction

#remove all quotes from file
zcat GSE48035_ILMN.counts.txt.gz | tr -d '"' > GSE48035_ILMN.counts.tmp.txt

#fix the header which is missing a column
head -n 1 GSE48035_ILMN.counts.tmp.txt | perl -ne 'print "Feature\t$_"' > header.txt

#replace the old header with the corrected one
grep -v --color=never ABRF GSE48035_ILMN.counts.tmp.txt | cat header.txt - > GSE48035_ILMN.counts.clean.txt

#cut out columns for the UHR (A) and HBR (B) samples, replicates 1-4, and PolyA vs Enrichment 
cut -f 1,2-5,6-9,18-21,22-25 GSE48035_ILMN.counts.clean.txt > GSE48035_ILMN.counts.subset.txt

#cleanup 
rm -f GSE48035_ILMN.counts.txt.gz GSE48035_ILMN.counts.tmp.txt GSE48035_ILMN.counts.clean.txt header.txt

```

Further limit these counts to those that correspond to known protein coding genes:

```bash
cd $RNA_HOME/batch_correction


```



### Introduction to Bioconductor SVA and ComBat-Seq in R
The ComBat-Seq package is made available as part of the [SVA package](https://www.bioconductor.org/packages/release/bioc/html/sva.html) for Surrogate Variable Analysis. This package is a collection of methods for removing batch effects and other unwanted variation in large datasets. It includes the ComBat method that has been widely used for batch correction of gene expression datasets, especially those generated on microarray platforms. ComBat-Seq is a modification of the ComBat approach that has been tailored to the count based data of bulk RNA-seq datasets. Particular advantages of the ComBat-Seq approach are that it: (1) uses a negative binomial regression model (the negative binomial distribution is thought to model the characteristics bulk RNA-seq count data), and (2) allows the output of corrected data that retain count nature of the data and can be safely fed into many existing methods for DE analysis (such as EdgeR and DESeq2).  

ComBat-Seq has a relatively short list of arguments, and for several of these we will use the default setting. Very basic documentation of these arguments can be found [here](https://rdrr.io/bioc/sva/man/ComBat_seq.html) and [here](https://github.com/zhangyuqing/ComBat-seq).

Our attempt to explain each of the ComBat-Seq arguments (for optional arguments, default is shown):
- `counts`. This is your matrix of gene expression read counts (raw counts). Each row is a gene, and each column is a sample, and each cell has an integer count for the number of RNA-seq counts observed for that gene/sample combination. In R we want this data to be passed into ComBat-Seq in matrix format (use `as.matrix()` if neccessary).
- `batch`. This is a vector describing the batches you are concerned about. For example, if you have six samples that you created RNA-seq data for but for the first four you used one library kit (A) but then you had to use a different library kit (B) for the last four samples, you would define your `batch` vector as: `c(1,1,1,1,2,2,2,2)`. 
- `group = NULL`. This is a vector describing your biological condition of interest. For example, if your experiment involved *pairs* of drug treated and untreated cells.  And you did 4 biological replicates.  You would define your `group` vector as: c(1,2,1,2,1,2,1,2).   
- `covar_mod = NULL`. If you have multiple biological conditions of interest, you can define these with `covar_mod` (covariates) instead of `group`.  For example, lets assume we have the same experiment as described above, except that we did four replicates (treated vs untreated pairs), but the first two replicates were done with male cells and the second two replicates were done with female cells.  You then would define a covariate matrix to supply to `covar_mod` as follows:
```R
treatment_group = c(1,2,1,2,1,2,1,2)
sex_group = c(1,1,1,1,2,2,2,2)
covariate_matrix = cbind(treatment_group, sex_group)
```
- `full_mod = TRUE`. If TRUE include condition of interest in model. Generally we believe this should be set to the default TRUE. We have yet to find a cohesive explanation for a situation where one would want this to be FALSE.
- `shrink = FALSE`. Whether to apply shrinkage on parameter estimation.  
- `shrink.disp = FALSE`. Whether to apply shrinkage on dispersion.  
- `gene.subset.n = NULL`. Number of genes to use in empirical Bayes estimation, only useful when shrink = TRUE.

A detailed discussion of *shrinkage* (related to the `shrink`, `shrink.disp`, and `gene_subset.n` arguments is beyond the scope of this tutorial. Briefly, shrinkage refers to a set of methods that attempt to correct for gene-specific variability in the counts observed in RNA-seq datasets. More specifically, it relates to the *dispersion parameter* of the [negative binomial distribution](https://en.wikipedia.org/wiki/Negative_binomial_distribution) used to model RNA-seq count data that can suffer from [overdispersion](https://en.wikipedia.org/wiki/Overdispersion). The dispersion parameter describes how much variance deviates from the mean. In simple terms, shrinkage methods are an attempt to correct for problematic dispersion. A more detailed discussion of these statistical concepts can be found in the [DESeq2 paper](https://pubmed.ncbi.nlm.nih.gov/25516281/). However, for our purposes here, the bottom line is that the ComBat-Seq authors state that "We have shown that applying empirical Bayes shrinkage is not necessary for ComBat-seq because the approach is already sufficiently robust due to the distributional assumption." So we will leave these arguments at their default `FALSE` settings.




